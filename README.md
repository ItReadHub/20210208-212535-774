# 抖音数据采集教程，详解Hook框架frida，让你在逆向工作中效率成倍提升！

> 短视频、直播数据实时采集接口，请查看文档： [TiToData](https://www.titodata.com?from=douyinarticle)


<br >免责声明：本文档仅供学习与参考，请勿用于非法用途！否则一切后果自负。<br >**<br >**一、frida简介**<br >frida是一款基于python + java 的hook框架，可运行在androidioslinuxwinosx等各平台，主要使用动态二进制插桩技术。**本期“安仔课堂”，ISEC实验室为大家详解frida，认真读完这篇文章会让你在逆向工作中效率成倍提升哦！**<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573039-c9dcc6b7-d71a-4614-9667-421df18010b5.jpeg#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&originHeight=225&originWidth=225&size=0&status=done&style=none&width=225)<br >**1、插桩技术**<br >插桩技术是指将额外的代码注入程序中以收集运行时的信息，**可分为两种：**<br >(1)源代码插桩[Source Code Instrumentation(SCI)]：额外代码注入到程序源代码中。<br >(2)二进制插桩（Binary Instrumentation）：额外代码注入到二进制可执行文件中。<br >●静态二进制插桩[Static Binary Instrumentation(SBI)]：在程序执行前插入额外的代码和数据，生成一个永久改变的可执行文件。<br >●动态二进制插桩[Dynamic Binary Instrumentation(DBI)]：在程序运行时实时地插入额外代码和数据，对可执行文件没有任何永久改变。<br >**2、你能用DBI做些什么呢**<br >（1）访问进程的内存<br >（2）在应用程序运行时覆盖一些功能<br >（3）从导入的类中调用函数<br >（4）在堆上查找对象实例并使用这些对象实例<br >（5）Hook，跟踪和拦截函数等等<br >**二、frida的安装**<br >今天我们用到的**frida框架分为两部分：** 一部分是运行在系统上的交互工具frida CLI; 另一部分是运行在目标机器上的代码注入工具 frida-server。<br >**1、frida CLI**<br >环境要求：<br >●系统环境 - Windows, macOS, or GNU/Linux<br >●Python – 最新的3.x版本<br >通过 pip 安装frida<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573028-b8591b4f-6bea-4f8c-b286-29b11fce8d99.png#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&originHeight=82&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图1<br >说明：<br >(1) 通过pip安装的frida是可以跟python绑定的； 另外frida现在也已经有了跟nodeJs绑定的版本， 因此也可以直接通过 npm 进行安装。<br >(2) frida CLI是安装的frida的其中一个工具，也是最常用的一个工具。<br >**2、frida server**<br >frida-server需要我们单独下载，在 frida项目的github上可以直接下载对应系统已经编译好的frida server<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573031-ab9f5c34-0582-48ea-bb8b-1cc6c6cc5445.png#align=left&display=inline&height=25&margin=%5Bobject%20Object%5D&originHeight=25&originWidth=288&size=0&status=done&style=none&width=288)<br >图2<br >我们需要下载的文件名的格式是： frida-server-(version)-(platform)-(cpu).xz<br >我试验的手机是nexus6p, cpu为arm64<br >所以我需要下载的是： frida-server-11.0.13-android-x86_64.xz；注意， frida-server 的版本一定要跟 frida CLI的版本一致。<br >将下载后的压缩包解压得到frida-server, 然后将该文件推送到Android设备上。<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573081-a475866a-eda8-45f3-aea0-894f0cda2d0d.png#align=left&display=inline&height=75&margin=%5Bobject%20Object%5D&originHeight=75&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图3<br >将Android设备上的frida-server添加执行权, 并运行该程序(需要root权限)<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573045-8547262e-d0ea-424b-ab53-96e18c0729ac.png#align=left&display=inline&height=194&margin=%5Bobject%20Object%5D&originHeight=194&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图4<br >**3、frida tools**<br >前面说过， frida CLI只是frida的其中一个工具，** frida 的工具共有6个：**<br >（1） frida CLI: 是一个交互式解释器（REPL），他的交互形式跟IPython很类似。<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573059-151a032b-cdca-421b-9a9c-b53134a67b07.jpeg#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=181&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图5<br >（2） frida-ps: 用于列出进程的一个命令行工具，当我们需要跟远程系统进行交互的时候，这个是非常有用的。<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573030-3cdd8cf7-61a0-43a4-bf3d-a0da7d706bf6.jpeg#align=left&display=inline&height=364&margin=%5Bobject%20Object%5D&originHeight=364&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图6<br >另外还有四个分别是： frida-trace, frida-discover, frida-ls-devices, frida-kill<br >由于不是经常用到，这边就不一一详细介绍了， 感兴趣的同学可以去frida的官网查看他们的详细介绍和用法。<br >**4、Java Api**<br >在Hook开始之前，有必要对Java注入相关的api做一个简单介绍， frida的注入脚本是Java， 因此我们后面都是通过js脚本来操作设备上的Java代码的。<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573041-defb196b-941c-468a-adc0-6fde22cb6aae.jpeg#align=left&display=inline&height=279&margin=%5Bobject%20Object%5D&originHeight=279&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图7<br >当我们获取到Java类之后，我们直通过接..implementations = function() {}的方式来hook wrapper类的method方法，不管是实例方法还是静态方法都可以。<br >由于js代码注入时可能会出现超时的错误， 为了防止这个问题，我们通常还需要在最外面包装一层setImmediate(function(){})的代码。<br >下面就是js的一个模板代码：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573042-3fd77538-e3c7-4a01-bda4-397ccaa1c4ba.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&originHeight=239&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图8<br >**三、 frida Hook实战**<br >接下来我将**通过制作一个类似微信抢红包的插件来演示frida的具体使用，**由于本文的主旨是教大家如何使用强大的frida框架， 所以侧重描述的是frida的使用， 而不会说明如何逆向微信。<br >**1、信息持久化到本地的拦截**<br >微信的每一条信息都会保存到本地数据库，这个保存的方法就是 com.tencent.wcdb.database.SQLiteDatabase 类的 insert()方法：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573021-e507f285-8565-4f99-ae38-fddc607bb6df.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&originHeight=216&originWidth=793&size=0&status=done&style=none&width=793)<br >图9<br >我们先看看每条信息保存的内容是什么：<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573060-a0321312-55ca-4220-8e5a-68ecf2dcea89.jpeg#align=left&display=inline&height=508&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图10<br >我们将手机连接到电脑， 然后通过frida将脚本注入到微信中：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573066-abc4de59-a576-4180-8a36-8356d3ace4fe.png#align=left&display=inline&height=76&margin=%5Bobject%20Object%5D&originHeight=76&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图11<br >用微信发送任意消息，我们可以看到控制台打印内容如下：<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573082-5590477f-1893-4721-96bf-c7e516d3a31a.jpeg#align=left&display=inline&height=413&margin=%5Bobject%20Object%5D&originHeight=413&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图12<br >arg1就是要插入数据的表名， arg2是表的主键， arg3是要插入表的数据的字段名称跟值的集合。这样， 我们就可以轻松拿到每条消息的内容和发送者等相关信息。<br >这里我们需要注意的是arg3里面以下几个值：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573066-944724a0-d1bd-4d5f-aba3-7b025dca0e52.png#align=left&display=inline&height=292&margin=%5Bobject%20Object%5D&originHeight=292&originWidth=514&size=0&status=done&style=none&width=514)<br >图13<br >当我们接收到一条红包消息的时候，我们可以看到红包信息的具体内容如下:<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573051-d65b3655-4f23-4e19-9769-a7822825a2f8.jpeg#align=left&display=inline&height=710&margin=%5Bobject%20Object%5D&originHeight=710&originWidth=747&size=0&status=done&style=none&width=747)<br >图14<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573100-f4b14506-45cd-4cbc-b590-375125fc7312.png#align=left&display=inline&height=391&margin=%5Bobject%20Object%5D&originHeight=391&originWidth=747&size=0&status=done&style=none&width=747)<br >图15<br >那我们要怎样通过这些信息来抢到红包呢?<br >**2、抢红包流程分析**<br >我们先来看一下，当我们点击打开红包之时发生了什么呢? 下面是反编译得到的打开红包按钮的点击事件：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573050-066146ad-f958-4e92-94fc-af9980ff9488.png#align=left&display=inline&height=109&margin=%5Bobject%20Object%5D&originHeight=109&originWidth=1080&size=0&status=done&style=none&width=1080)<br >图16<br >这行代码其实就是发送抢红包的请求, ad 就是一个网络请求类, 那么需要构成这个请求又需要哪些参数呢?<br >我们单独看看 ad 类的创建：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573068-8cf7506e-2a52-4f76-80fb-c5830346cafa.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&originHeight=124&originWidth=747&size=0&status=done&style=none&width=747)<br >图17<br >其中第1,2,3,4,9个参数都是来自luckyMoneyReceiveUI.kRG, 第8个参数是固定的 "v1.0"<br >接下来我们来打印一下第5,6,7个参数是什么：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573076-a9391f29-55ba-46fa-a6d5-d72a26b8da40.png#align=left&display=inline&height=477&margin=%5Bobject%20Object%5D&originHeight=477&originWidth=747&size=0&status=done&style=none&width=747)<br >图18<br >重新加载这段js代码, 然后我们打开一个红包, 我们可以看到控制台打印如下信息：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573097-9e563a90-27f8-4191-855a-45ec7a406988.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=747&size=0&status=done&style=none&width=747)<br >图19<br >第5,6个参数其实是自己的头像跟昵称信息,第7个是发送者的信息，而第4个参数跟上面红包内容里面的nativeurl的值是一样的。<br >那luckyMoneyReceiveUI.kRG 中的msgType,bxk,kLZ,ceR,kRC这些要怎么得到呢?<br >luckyMoneyReceiveUI.kRG 这个字段的类型是: com.tencent.mm.plugin.luckymoney.b.ag，ag类跟之前提到的ad类一样, 都是一个请求类, 他们都是继承同一个类。其中, msgType是固定的 1，bxk,kLZ,ceR 是在ag的构造方法里面就被初始化的：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573103-b653dcc5-5911-4f74-bc6c-44e61add6742.png#align=left&display=inline&height=307&margin=%5Bobject%20Object%5D&originHeight=307&originWidth=692&size=0&status=done&style=none&width=692)<br >图20<br >而kRC则是在里面的a方法里面被赋值的：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573100-26edd6d8-d377-4b94-a706-ec2cf698e5aa.png#align=left&display=inline&height=37&margin=%5Bobject%20Object%5D&originHeight=37&originWidth=490&size=0&status=done&style=none&width=490)<br >图21<br >……<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573100-a11cdb65-e7ff-4724-9eca-180116239300.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&originHeight=78&originWidth=509&size=0&status=done&style=none&width=509)<br >图22<br >这个a方法是请求类发起请求之后的一个回调，而在 LuckyMoneyReceiveUI的 OnCreate 方法里面我们可以看到 com.tencent.mm.plugin.luckymoney.b.ag 是怎么被构造出来的：<br >![](https://cdn.nlark.com/yuque/0/2021/jpeg/97322/1612790573104-9a33d55e-f4d8-4480-a3dd-b539328b3f9a.jpeg#align=left&display=inline&height=465&margin=%5Bobject%20Object%5D&originHeight=465&originWidth=909&size=0&status=done&style=none&width=909)<br >图23<br >第一个参数是nativeurl中的channelid;<br >第二个参数是nativeurl中的sendid;<br >第三个参数是nativeurl本身;<br >第四个参数可以用0;<br >第五个参数是也是固定的 "v1.0"<br >经过上面的分析之后, 我们的思路就清晰了, 在收到红包信息后我们解析出红包信息里面nativeurl, channelid, sendid, 根据这些参数发送一个com.tencent.mm.plugin.luckymoney.b.ag的请求, 之后得到timingIdentifier, 最后根据得到的timingIdentifier 再发送一个com.tencent.mm.plugin.luckymoney.b.ad的请求就可以抢到红包了。<br >**3、模拟请求**<br >到这里我们也就剩最后一个问题了, 那就是怎么把请求发送出去？这个我们同样可以看看微信, 我们跟踪到红包界面的请求都是通过下面的方法发送的：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573104-ecff99c6-5a7d-4ed0-89ac-4aa421e14eeb.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&originHeight=198&originWidth=803&size=0&status=done&style=none&width=803)<br >图24<br >上面的g.Eh().dpP得到的是一个专门发送请求的Network, 得到这个Network之后我们就可以调用他的a方法把这个请求发送出去。需要注意的是frida不支持直接通过.dpP的方式拿到属性, 不过没关系, 我们可以通过反射的方式来获取：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573120-7df52947-7906-41aa-959b-c4dca4f82d3f.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&originHeight=262&originWidth=702&size=0&status=done&style=none&width=702)<br >图25<br >得到Network之后我们就开始发送请求了：<br >第一步是收到红包信息之后要解析出ContentValues里面的信息,并根据解析出的内容发送ag请求。<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573122-75d4bb37-bf83-4855-bfdf-9603c989fe5f.png#align=left&display=inline&height=720&margin=%5Bobject%20Object%5D&originHeight=720&originWidth=746&size=0&status=done&style=none&width=746)<br >图26<br >我们单独把红包信息的content的解析拿出来：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573108-a6ec7d97-d927-4374-ae61-b07f3124064e.png#align=left&display=inline&height=503&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=746&size=0&status=done&style=none&width=746)<br >图27<br >nativeurl的具体内容如下：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573107-68422871-3646-421b-a8a0-1f08a6b2490e.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&originHeight=106&originWidth=716&size=0&status=done&style=none&width=716)<br >图28<br >通过上面的解析之后我们就可以得到如下的info：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573106-09dffda5-6263-4218-bf47-40a5e6f3e509.png#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=747&size=0&status=done&style=none&width=747)<br >图29<br >第二步是Hook ag请求的a方法, 在里面我们可以拿到timingIdentifier的值：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573159-2ff62a8a-4784-4511-a0fa-53321f930c36.png#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=748&size=0&status=done&style=none&width=748)<br >图30<br >注意:当一个类里面有重载的方法的时候, 我们需要用.overload(paramtype...)来表示我们hook的是哪个重载方法。<br >最后我们还需要改造一下之前Hook的SQL的insert方法, 我们需要过滤出表名为message,类型为436207665的消息：<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573139-fe15d2d2-5e64-4e7f-8748-675bbf90ec5f.png#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&originHeight=314&originWidth=693&size=0&status=done&style=none&width=693)<br >图31<br >接下来就可以开始体验我们的抢红包插件了!<br >![](https://cdn.nlark.com/yuque/0/2021/png/97322/1612790573112-23b6c9d8-eb32-43a4-bed6-bae091c2a703.png#align=left&display=inline&height=44&margin=%5Bobject%20Object%5D&originHeight=44&originWidth=582&size=0&status=done&style=none&width=582)<br >图32<br >最后请看效果：<br >![](https://cdn.nlark.com/yuque/0/2021/gif/97322/1612790573130-e571793a-0e6d-4f26-8a2a-1444886bc419.gif#align=left&display=inline&height=534&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=300&size=0&status=done&style=none&width=300)<br >图33<br >**四、附录**<br >本次试验环境如下：<br >微信版本： 6.6.7<br >frida版本： 11.0.13<br >frida-server: frida-server-11.0.13-android-x86_64<br >Android: 7.0
